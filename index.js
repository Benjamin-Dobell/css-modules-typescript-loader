const fs = require('fs');
const path = require('path');
const loaderUtils = require('loader-utils');
const LineDiff = require('line-diff');

const defaultBanner =
  '// This file is automatically generated.\n// Please do not change this file!';

const cssModuleExport = '  const cssExports: CssExports;\n  export = cssExports;';

const nodeModulesSubPath = '/node_modules/';

const noDeclarationFileError = (filePath) =>
  new Error(
    `Generated type declaration does not exist. Run webpack and commit the type declaration for '${filePath}'`
  );

const typeMismatchError = (filePath, expected, actual) => {
  const diff = new LineDiff(actual, expected).toString();

  return new Error(
    `Generated type declaration file is outdated. Run webpack and commit the updated type declaration for '${filePath}'\n\n${diff}`
  );
};

const moduleDeclaration = (module, exports) => {
  const interfaceFields = exports
    .sort()
    .map(key => `    '${key}': string;`)
    .join('\n');

  return `declare module '${module.path}' {\n  interface CssExports {\n${interfaceFields}\n  }\n${cssModuleExport}\n}\n`;
};

const resolveModulePath = (contexts, resourcePath, outputDirectory) => {
  for (const context of contexts) {
    if (resourcePath.startsWith(context)) {
      const modulePath = resourcePath.substring(context.length + 1);

      return {
        path: modulePath,
        output: `${path.join(outputDirectory, modulePath)}.ts`,
      };
    }
  }

  const nodeModulesIndex = resourcePath.lastIndexOf(nodeModulesSubPath);

  if (nodeModulesIndex > 0) {
    const modulePath = resourcePath.substring(nodeModulesIndex + nodeModulesSubPath.length);

    return {
      path: modulePath,
      output: `${path.join(outputDirectory, '__node_modules', modulePath)}.ts`, // Directories called `node_modules` tend to be excluded in .tsconfig
    };
  }

  return null;
};

const validModes = ['emit', 'verify'];

const isFileNotFound = err => err && err.code === 'ENOENT';

const makeDoneHandlers = (callback, content, rest) => ({
  failed: e => callback(e),
  success: () => callback(null, content, ...rest)
});

const makeFileHandlers = filePath => {
  const directory = path.dirname(filePath);

  if (!fs.existsSync(directory)) {
    fs.mkdirSync(directory, { recursive: true });
  }

  return {
    read: handler => fs.readFile(filePath, { encoding: 'utf-8' }, handler),
    write: (content, handler) => fs.writeFile(filePath, content, { encoding: 'utf-8' }, handler),
  }
};

const validateStringArray = option => {
  return Array.isArray(option) && option.findIndex(entry => typeof entry !== 'string') < 0;
}

function generateModuleDeclaration(content, failed, success) {
  const { resourcePath } = this;
  const rootContext = this.options ? this.options.context : this.rootContext;

  const {
    banner = defaultBanner,
    contexts = ['src'],
    excludeModules = [],
    mode = 'emit',
    outputDirectory = contexts.length === 1 && path.join(contexts[0], 'css-modules'),
  } = loaderUtils.getOptions(this) || {};

  if (banner && typeof banner !== 'string') {
    throw new Error('The banner option must be a string or null')
  }

  if (!validateStringArray(excludeModules)) {
    throw new Error('The excludeModules option must be an array of strings');
  }

  if (!contexts || !validateStringArray(contexts)) {
    throw new Error('The contexts option must be an array of strings');
  }

  if (!validModes.includes(mode)) {
    throw new Error(`Invalid mode option: ${mode}`);
  }

  if (typeof outputDirectory !== 'string') {
    throw new Error('The outputDirectory option must be a string');
  }

  const resolvedContexts = contexts.map(context => path.resolve(rootContext, context))

  const module = resolveModulePath(resolvedContexts, resourcePath, outputDirectory);

  if (excludeModules.includes(module.path)) {
    success();
    return;
  }

  if (!module) {
    throw new Error(`Cannot determine TypeScript module path for ${resourcePath}\nPlease configure the contexts option to match your .tsconfig`);
  }

  const { read, write } = makeFileHandlers(module.output);

  const keyRegex = /"([^\\"]+)":/g;
  let match;
  const cssExports = [];

  const localExports = content.split('exports.locals')[1];

  while ((match = keyRegex.exec(localExports))) {
    if (cssExports.indexOf(match[1]) < 0) {
      cssExports.push(match[1]);
    }
  }

  const cssModuleDefinition = `${banner ? banner + "\n" : ''}${moduleDeclaration(module, cssExports)}`;

  if (mode === 'verify') {
    read((err, fileContents) => {
      if (isFileNotFound(err)) {
        return failed(noDeclarationFileError(module.output));
      }

      if (err) {
        failed(err);
      }

      if (cssModuleDefinition !== fileContents) {
        return failed(typeMismatchError(module.output, cssModuleDefinition, fileContents));
      }

      success();
    });
  } else {
    read((_, fileContents) => {
      if (cssModuleDefinition !== fileContents) {
        write(cssModuleDefinition, err => {
          if (err) {
            failed(err);
          } else {
            success();
          }
        });
      } else {
        success();
      }
    });
  }
}

module.exports = function(content, ...rest) {
  const { failed, success } = makeDoneHandlers(this.async(), content, rest);

  try {
    if (fs.existsSync(`./${path.basename(this.resourcePath)}.d.ts`)) {
      success();
    } else {
      generateModuleDeclaration.call(this, content, failed, success);
    }
  } catch (e) {
    failed(e);
  }
};
